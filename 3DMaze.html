<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Maze Screensaver</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
        }
        
        #canvas3d {
            width: 100vw !important;
            height: 100vh !important;
            display: block !important;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <canvas id="canvas3d"></canvas>

    <script>
        // 3D Maze Screensaver using Three.js
        // Parse URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const mazeSize = parseInt(urlParams.get('size') || '20');
        const moveSpeedParam = parseFloat(urlParams.get('speed') || '1');
        const wallTextureType = urlParams.get('wall') || 'brick';
        const floorTextureType = urlParams.get('floor') || 'wood';
        const ceilingTextureType = urlParams.get('ceiling') || 'ceiling';
        
        let mazeScene, mazeCamera, mazeRenderer;
        let maze = [];
        let cellSize = 10;
        let wallHeight = 5;
        
        // Player position and movement
        let playerX = 0;
        let playerZ = 0;
        let playerAngle = 0;
        let moveSpeed = 0.08 * moveSpeedParam;
        let turnSpeed = 0.03 * moveSpeedParam;
        let animationFrame = null;
        let lastFrameTime = 0;
        
        // Navigation state
        let isMoving = false;
        let isTurning = false;
        let targetAngle = 0;
        let moveProgress = 0;
        let currentDirection = 0;
        
        const TARGET_FPS = 60;
        const FRAME_INTERVAL = 1000 / TARGET_FPS;
        
        // Maze generation
        function generateMaze(size) {
            console.log('Generating new maze with size:', size, 'at', Date.now());
            const m = [];
            for (let i = 0; i < size; i++) {
                m[i] = [];
                for (let j = 0; j < size; j++) {
                    m[i][j] = [1, 1, 1, 1];
                }
            }
            
            const stack = [];
            const visited = new Set();
            
            function cellKey(x, z) {
                return `${x},${z}`;
            }
            
            function getUnvisitedNeighbors(x, z) {
                const neighbors = [];
                const dirs = [
                    { dx: 0, dz: -1, wall: 0, opposite: 2 },
                    { dx: 1, dz: 0, wall: 1, opposite: 3 },
                    { dx: 0, dz: 1, wall: 2, opposite: 0 },
                    { dx: -1, dz: 0, wall: 3, opposite: 1 }
                ];
                
                for (const dir of dirs) {
                    const nx = x + dir.dx;
                    const nz = z + dir.dz;
                    if (nx >= 0 && nx < size && nz >= 0 && nz < size && !visited.has(cellKey(nx, nz))) {
                        neighbors.push({ x: nx, z: nz, wall: dir.wall, opposite: dir.opposite });
                    }
                }
                
                return neighbors;
            }
            
            let currentX = Math.floor(Math.random() * size);
            let currentZ = Math.floor(Math.random() * size);
            visited.add(cellKey(currentX, currentZ));
            stack.push({ x: currentX, z: currentZ });
            
            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                const neighbors = getUnvisitedNeighbors(current.x, current.z);
                
                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    m[current.z][current.x][next.wall] = 0;
                    m[next.z][next.x][next.opposite] = 0;
                    visited.add(cellKey(next.x, next.z));
                    stack.push({ x: next.x, z: next.z });
                } else {
                    stack.pop();
                }
            }
            
            console.log('Maze generated successfully');
            return m;
        }
        
        // Initialize scene
        function initMazeScene() {
            console.log('Initializing maze scene...');
            const canvas = document.getElementById('canvas3d');
            
            mazeScene = new THREE.Scene();
            mazeScene.background = new THREE.Color(0x000000);
            mazeScene.fog = new THREE.Fog(0x000000, 0, cellSize * 5);
            
            mazeCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, cellSize * 10);
            mazeCamera.position.y = wallHeight / 2;
            
            mazeRenderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: false });
            mazeRenderer.setSize(window.innerWidth, window.innerHeight);
            mazeRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
            mazeScene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mazeScene.add(dirLight);
            mazeCamera.add(dirLight);
            mazeScene.add(mazeCamera);
            
            maze = generateMaze(mazeSize);
            buildMazeGeometry();
            findStartPosition();
            
            window.addEventListener('resize', onMazeWindowResize, false);
            console.log('Maze scene initialized successfully');
        }
        
        // Create textures
        function createBrickTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, 0, 128, 128);
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 2;
            
            for (let y = 0; y < 128; y += 32) {
                for (let x = 0; x < 128; x += 64) {
                    const offset = (y / 32) % 2 === 0 ? 0 : 32;
                    ctx.strokeRect(x + offset, y, 64, 32);
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }
        
        function createFloorTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#505050';
            ctx.fillRect(0, 0, 128, 128);
            
            for (let i = 0; i < 100; i++) {
                ctx.fillStyle = `rgba(${Math.random() * 50 + 50}, ${Math.random() * 50 + 50}, ${Math.random() * 50 + 50}, 0.3)`;
                ctx.fillRect(Math.random() * 128, Math.random() * 128, Math.random() * 10 + 2, Math.random() * 10 + 2);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }
        
        function createCeilingTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#303030';
            ctx.fillRect(0, 0, 128, 128);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }
        
        // Build maze geometry
        function buildMazeGeometry() {
            const wallTexture = createBrickTexture();
            const floorTexture = createFloorTexture();
            const ceilingTexture = createCeilingTexture();
            
            const wallMaterial = new THREE.MeshPhongMaterial({ map: wallTexture, side: THREE.DoubleSide });
            const floorMaterial = new THREE.MeshPhongMaterial({ map: floorTexture, side: THREE.DoubleSide });
            const ceilingMaterial = new THREE.MeshPhongMaterial({ map: ceilingTexture, side: THREE.DoubleSide });
            
            for (let z = 0; z < mazeSize; z++) {
                for (let x = 0; x < mazeSize; x++) {
                    const cell = maze[z][x];
                    const posX = (x - mazeSize / 2) * cellSize;
                    const posZ = (z - mazeSize / 2) * cellSize;
                    
                    if (cell[0] === 1) {
                        const geometry = new THREE.PlaneGeometry(cellSize, wallHeight);
                        const wall = new THREE.Mesh(geometry, wallMaterial);
                        wall.position.set(posX, wallHeight / 2, posZ - cellSize / 2);
                        wall.rotation.y = 0;
                        mazeScene.add(wall);
                    }
                    
                    if (cell[1] === 1) {
                        const geometry = new THREE.PlaneGeometry(cellSize, wallHeight);
                        const wall = new THREE.Mesh(geometry, wallMaterial);
                        wall.position.set(posX + cellSize / 2, wallHeight / 2, posZ);
                        wall.rotation.y = Math.PI / 2;
                        mazeScene.add(wall);
                    }
                    
                    if (cell[2] === 1) {
                        const geometry = new THREE.PlaneGeometry(cellSize, wallHeight);
                        const wall = new THREE.Mesh(geometry, wallMaterial);
                        wall.position.set(posX, wallHeight / 2, posZ + cellSize / 2);
                        wall.rotation.y = Math.PI;
                        mazeScene.add(wall);
                    }
                    
                    if (cell[3] === 1) {
                        const geometry = new THREE.PlaneGeometry(cellSize, wallHeight);
                        const wall = new THREE.Mesh(geometry, wallMaterial);
                        wall.position.set(posX - cellSize / 2, wallHeight / 2, posZ);
                        wall.rotation.y = -Math.PI / 2;
                        mazeScene.add(wall);
                    }
                    
                    const floorGeometry = new THREE.PlaneGeometry(cellSize, cellSize);
                    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                    floor.rotation.x = -Math.PI / 2;
                    floor.position.set(posX, 0, posZ);
                    mazeScene.add(floor);
                    
                    const ceilingGeometry = new THREE.PlaneGeometry(cellSize, cellSize);
                    const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
                    ceiling.rotation.x = Math.PI / 2;
                    ceiling.position.set(posX, wallHeight, posZ);
                    mazeScene.add(ceiling);
                }
            }
        }
        
        function findStartPosition() {
            for (let z = 0; z < mazeSize; z++) {
                for (let x = 0; x < mazeSize; x++) {
                    const cell = maze[z][x];
                    for (let dir = 0; dir < 4; dir++) {
                        if (cell[dir] === 0) {
                            playerX = x;
                            playerZ = z;
                            currentDirection = dir;
                            playerAngle = dir * Math.PI / 2;
                            updateCameraPosition();
                            return;
                        }
                    }
                }
            }
        }
        
        function updateCameraPosition() {
            const worldX = (playerX - mazeSize / 2) * cellSize;
            const worldZ = (playerZ - mazeSize / 2) * cellSize;
            mazeCamera.position.x = worldX;
            mazeCamera.position.z = worldZ;
            mazeCamera.rotation.y = -playerAngle;
        }
        
        function canMove(x, z, direction) {
            if (x < 0 || x >= mazeSize || z < 0 || z >= mazeSize) return false;
            return maze[z][x][direction] === 0;
        }
        
        function getNextMove() {
            const dirs = [
                { dx: 0, dz: -1 },
                { dx: 1, dz: 0 },
                { dx: 0, dz: 1 },
                { dx: -1, dz: 0 }
            ];
            
            const rightDir = (currentDirection + 1) % 4;
            const leftDir = (currentDirection + 3) % 4;
            const backDir = (currentDirection + 2) % 4;
            
            if (canMove(playerX, playerZ, rightDir)) {
                return { turn: rightDir, move: true };
            }
            
            if (canMove(playerX, playerZ, currentDirection)) {
                return { turn: currentDirection, move: true };
            }
            
            if (canMove(playerX, playerZ, leftDir)) {
                return { turn: leftDir, move: true };
            }
            
            return { turn: backDir, move: false };
        }
        
        function animateMaze() {
            animationFrame = requestAnimationFrame(animateMaze);
            
            if (!mazeCamera || !mazeRenderer || !mazeScene) return;
            
            const currentTime = performance.now();
            const deltaTime = currentTime - lastFrameTime;
            
            if (deltaTime < FRAME_INTERVAL) {
                return;
            }
            
            lastFrameTime = currentTime - (deltaTime % FRAME_INTERVAL);
            
            if (isTurning) {
                const angleDiff = targetAngle - playerAngle;
                const normalizedDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));
                
                if (Math.abs(normalizedDiff) < 0.05) {
                    playerAngle = targetAngle;
                    isTurning = false;
                    currentDirection = Math.round(targetAngle / (Math.PI / 2)) % 4;
                    if (currentDirection < 0) currentDirection += 4;
                    updateCameraPosition();
                } else {
                    playerAngle += Math.sign(normalizedDiff) * turnSpeed;
                    updateCameraPosition();
                }
            } else if (isMoving) {
                moveProgress += moveSpeed;
                
                if (moveProgress >= 1) {
                    moveProgress = 0;
                    isMoving = false;
                    
                    const dirs = [
                        { dx: 0, dz: -1 },
                        { dx: 1, dz: 0 },
                        { dx: 0, dz: 1 },
                        { dx: -1, dz: 0 }
                    ];
                    const dir = dirs[currentDirection];
                    playerX += dir.dx;
                    playerZ += dir.dz;
                    
                    updateCameraPosition();
                } else {
                    const dirs = [
                        { dx: 0, dz: -1 },
                        { dx: 1, dz: 0 },
                        { dx: 0, dz: 1 },
                        { dx: -1, dz: 0 }
                    ];
                    const dir = dirs[currentDirection];
                    const startX = (playerX - mazeSize / 2) * cellSize;
                    const startZ = (playerZ - mazeSize / 2) * cellSize;
                    const targetX = startX + dir.dx * cellSize;
                    const targetZ = startZ + dir.dz * cellSize;
                    
                    mazeCamera.position.x = startX + (targetX - startX) * moveProgress;
                    mazeCamera.position.z = startZ + (targetZ - startZ) * moveProgress;
                }
            } else {
                const nextMove = getNextMove();
                
                if (nextMove.turn !== currentDirection) {
                    targetAngle = nextMove.turn * Math.PI / 2;
                    isTurning = true;
                } else if (nextMove.move && canMove(playerX, playerZ, currentDirection)) {
                    isMoving = true;
                    moveProgress = 0;
                }
            }
            
            mazeRenderer.render(mazeScene, mazeCamera);
        }
        
        function onMazeWindowResize() {
            if (mazeCamera && mazeRenderer) {
                mazeCamera.aspect = window.innerWidth / window.innerHeight;
                mazeCamera.updateProjectionMatrix();
                mazeRenderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        // Initialize on page load
        window.addEventListener('DOMContentLoaded', function() {
            console.log('DOMContentLoaded - starting maze');
            initMazeScene();
            lastFrameTime = performance.now();
            animateMaze();
        });
    </script>
</body>
</html>
